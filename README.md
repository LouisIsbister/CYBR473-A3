# CYBR473 Assignment 3

### **Introduction**
This repository is used to keep track of my submission for the final CYBR473 (Malware Analysis) assignment, with the goal of this assignment being to develop a proof-of-concept malware.  

### **How to Build the Malware:**
1. If you would like to compile this malware yourself you can do so by utilising the `Makefile`, this builds the executable using the apropriate command and includes the required compile-time linked libraries.
   * However, you may notice that I have hard-coded the path to my 32-bit mingw gcc compiler and the `-m32` compiler flag is used. I have done this to ensure it is compiled to a 32-bit executable allowing it to run in both 64 and 32-bit Windows environments. As such, you will likely have to replace the compiler path with that of you own 32-bit compiler if you wish to use the make file.
   * Otherwise, simply construct the compiler command to be specific to you environment.
2. Once compiled, you can then pack the executable using upx by simply navigating to the location of the generated `donotexecute.exe` file and executing `upx donotexecute.exe` (if you have upx installed).

### **How to Setup/Test/Run and Interact With the C2 Using LocalHost in a Secure Environment:**
1. Firstly, open a new command prompt/powershell window and navigate to the `c2` directory and run the Flask server using `py server.py`.
2. Then, open another window and run `controller.py` which is also located in the `c2` directory. This script allows you to send commands to registered clients via the C2 server, view captured key logs, and see all client information.
3. Then, open a third command prompt as admin (this is important) and navigate to the directory that stores the malware executable (called `donotexecute.exe`), and execute it (sorry for the mixed signals).
4. Once running, the server window should recieve an HTTP GET request from the client, registering them with the C2 server. At this point everything is set up and ready to go, to test the various capabiltiies you can follow the below instructions:
   * `slp`, `shd`, and `pwn`: use the `controller` window to send these commands in the specified format to the client machine. If you need help simply enter the `help` command. Once sent the result of these commands should be visible in the malware window, there will likely be a delay before they are executed as the commands are polled at regular intervals of 20 seconds.
   * Listing clients: simply enter the command `clients` to list all clients including their id, how long it has been since their last beacon, and whether they are currently active.
   * Viewing log files: to view captured log files simply enter the command `logs` followed by the client id. If the client id is unknown you can list all clients using the `clients` commands as described earlier.


### **Completion Defenses Bypassed**
Each number refers to the order at which the defense appear in the assignment brief.
| Defense | How I Bypassed It|
|:--------|:-----------------|
|1. *The defender may use antivirus software to detect the malware.*|<p>1. To evade this defense I utilised UPX to compress and obfuscate my the malware exectuable. This allowed me to hide the original byte patterns and obfuscate hard coded strings, making static analysis and detection of the malware package more difficult.</p>|
|3. *The defender may look for evidence of keylog files on infected machines.*|<p>1. To evade this defenese I took a slightly naive approach and simply kept track of all logged keys in a large buffer stored in my `KEY_LOGGER` struct defined in `keylogger.h`. This poses an obvious limitation that any keys logged at the time the client machine is shutdown, will unfortunately be lost.</p>|
|5. *Reboot the client machines so that the malware will be forced to shut down.*|<p>1. I utilised a registry key to ensure that even if the client machine is rebooted my malware will launch itself when the infected user logs back into their account. This is achieved by creating a value in `SOFTWARE\Microsoft\Windows\CurrentVersion\Run` under the root key `HKEY_CURRENT_USER` to launch my malware from `System32` on user login.</p>|
|7. *You know that they are likely to use a disassembler like IDA-pro or ghidra to analyse your malware.*|<p>1. As can be seen at the beginning of the main.c file I employ two inline assembly techniques to confuse dissembler software. This is achieved primarily through the code `call label; .ascii ..` this tricks the dissembler into believing the call instruction attempted to envoke an invalid command.</p>|
|8. *The defender may be running your malware inside a standard sandbox for quick dynamic analysis.*|<p>1. My first approach to bypassing standard sandbox analysis is simply to immediately sleep for 10 minutes on execution, this is because some sandboxes only anaylse for a few minutes.</p><p>2. My second anti-sandbox technique was to check whether the number of running processes is less than 15. This is because most sandboxes are lightweight for quick and effecicient analysis, as such they often run with minimal processes!</p>|
|9. *They may also run your malware executable in a debugger like OllyDbg or x64dbg for deep dynamic analysis. They may try to set breakpoints, trace execution, or step through code.*|<p>1. The first anti-debugger technique I utilised was a time-based check each time a command is executed on the client side. The `processCommands` method in the `commands.c` file sequentially executes each command recieved from the C2 server by calling the `executeCommand` method, a likely target for an analyst to debug. As such, I compute the time it takes to execute the command, if it is greater than 2.5 seconds then a breakpoint has likely been set and the process immediately terminates.</p><p>2. My second anti-debugger technique is to simply envoke the Windows API function `IsDebuggerPresent`, if it returns true then terminate immediately!</p><p>3. The final anti-debugging technique I employed was to utilise `SetLastError`, `OutputDebugString`, and `GetLastError`. If the set error value changes then we likely know that a debugger is present.</p><p>I also employed process enumeration to check for running processes with names such as "OLLYDBG" or "Dbg" (for WinDbg), however, I will credit process enumeration in the next defense.|
|10. *The defender may be analysing your malware for deep analysis inside a virtual machine, e.g. using VirtualBox.*|<p>1. Virtual Machine's (VM) create registry keys to store configurations, settings, and facilitate VM to host exchanges. However, these keys also allow malware to determine if its in a vitual environment, as such, my first anti-malware technique simply checks for the existence of a range of known VMware and VirtualBox (VBox) registry keys using `RegOpenKeyExA`, if one is found then the process immediately terminates.</p><p>2. My second anti-VM technique is to enumerate all running processes and check whether their name matches known processes associated with the VM providers VMware and VBox. For example, "vmtoolsd" (VMware) and "VBoxService" (VBox) are two such background processes that if detected cause the malware to instantly terminate.</p><p>3. My last anti-VM technique inspects the first six characters of the client machine's MAC address for known VM provider MAC ranges. For example, VBox version 5.2 and later utilises the prefix "08:00:27" and many VMware machines MACs start with "00:50:56". As such, if the clients MAC matches that of a known VM provider the malware immediately exits.</p>|
|11. *The malware analyst will eventually find the hard-coded key and will be able to decipher the communications of malware with the C2.*|1. I bypassed this defence by generating a random single-byte encoding key for each new client on the server-side, instead of hard-coding the key in both the client and C2. When a client registers with the C2 it responds with the random byte, ensuring that if the encoding key is discovered on one infected machine it cannot be used to decipher communication of other infected machines!|
|12. *The malware analyst will spoof the C&C server itself to send the shutdown command to all hosts on the network to try and deactivate the malware ("kill-switch").*|1. This defense is bypassed as all commands sent to the malware are encoded using the previously mentioned random encoding key. As such, the spoofed C2 server might try and send the command `shd <user_id>` to every client that attempts to poll commands. However, unless the spoofed C2 knows the correct encoding key for each client, then when the command is recieved and decoded by the malware it will not be recognised as a valid command. As such, the spoofed C2 would need to correctly encode each of the shutdown messags for every infected client in order successfully shut down each one!|
|13. *The defender may look for suspicious processes or unusual binaries on disk. They may trust processes signed by Microsoft or running from `C:\Windows\System32`*.|1. My malware bypasses this defense by creating and launching a copy of itself in the `System32` directory when it is first launched. When the privileged version is launched, it deletes the old executableto ensure their are no "untrusted" artifacts of the malware left in the clients file system!|

### **Dependencies and Assumptions**
The only dependency required to compile and execute my malware are that you must have admin privileges. This is because the malware must be executed as admin when it is first run, otherwise the it will be unable to access `System32`, however, if you only want to test the keylogger simply change the `main` method to only envoke the `exec` method in `main.c`.

### How no Visible Window Was Achieved:
To prevent a window from being opened when the new process is created in the function `copyToSys32AndLaunch` I added the following flags to the process setup structures: 
```c
si.dwFlags |= STARTF_USESHOWWINDOW; // tells Windows to use the value of wShowWindow to determine how to display the new process's window
si.wShowWindow = SW_HIDE; // sets desired window display state to hidden
dwCreationFlags = CREATE_NO_WINDOW; // flag in the CreateProcess to not create a console window at all
```
These flags prevent any window from being created, even for console applications!