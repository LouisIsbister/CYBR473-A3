# C473-A3

### Introduction
This repository is used to keep track of my submission for the final CYBR473 (Malware Analysis) assignment, with the goal of this assignment being to develop a proof-of-concept malware. 
   
### How to Build/Run/Test Using LocalHost in a Secure Environment:
1. If you would like to compile this malware yourself you can do so using my `Makefile`, this builds the executable using the apropriate command and includes the required linked compile-time libraries
   * However, you may notice that I have hard-coded the path to my 32-bit mingw gcc compiler and utilise the `-m32` compiler flag. I have done this to ensure it is compile to a 32-bit executable allowing it to be exectuabel in both 64 and 32-bit Windows environments. As such, you will have to replace the compiler path with you own 32-bit compiler.

### How to Setup and Interact With C2
1. Firstly, open a new command prompt/powershell window and navigate to the `server` directory and run the Flask server using `py server.py`.
2. Then, open another window and run `controller.py` which is also located in the `server` directory. This script allows you to send commands to the C2 server, view captured key logs, and see all client information.
3. Then, open a third command prompt as admin (this is important) and navigate to the directory that stores the malware executable (called `donotexecute.exe`), and execute it (sorry for the mixed signals).
4. Once running the server window should recieve an HTTP GET request from the client, registering them with the C2 server. At this point everything is set up and ready to go, to test the various capabiltiies you can follow the below instructions:
   * `SLP`, `SHD`, and `PWN`: use the `controller` window to send these commands in the specified format to the client machine. If you need help simply enter the `help` command. Once sent the result of these commands should be visible in the malware window, there will likely be a delay before they are executed as the commands are polled at regular intervals of 20 seconds.
   * Listing clients: simply enter the command `clients` to list all clients including their id, how long it has been since their last beacon, and whether they are currently active.
   * Viewing log files: to view captured log files simply enter the command `logs` followed by the client id. If the client id is unknown you can the list all clients using the command described before.


### Defenses Bypassed 
Each number refers to the order at which the defense appear in the assignment brief.
| Defense | How I Bypassed It|
|:--------|:-----------------|
|1. *The defender may use antivirus software to detect the malware.*|<p>1. To evade this defense I utilised UPX to compress and obfuscate my the malware exectuable. This allowed me to hide the original byte patterns and obfuscate hard coded strings, making static analysis and detection of the malware package more difficult.</p>|
|3. *The defender may look for evidence of keylog files on infected machines.*|<p>1. To evade this defenese I took a slightly naive approach and simply kept track of all logged keys in a large buffer stored in my `KEY_LOGGER` struct defined in `keylogger.h`. This poses an obvious limitation that any keys logged at the time the client machine is shutdown, will unfortunately be lost.</p>|
|5. *Reboot the client machines so that the malware will be forced to shut down.*|<p>1. I utilised a registry key to ensure that even if the client machine is rebooted my malware will launch itself when the infected user logs back into their account. This is achieved by creating a value in `SOFTWARE\Microsoft\Windows\CurrentVersion\Run` under the root key `HKEY_CURRENT_USER` to launch my malware from System32 on user login.</p>|
|7. *You know that they are likely to use a disassembler like IDA-pro or ghidra to analyse your malware.*|<p>1. As can be seen at the beginning of the main.c file I employ two inline assembly techniques to confuse dissembler software. The first two lines `.byte 0xEB, 0xFF` and `.byte 0xC0, 0x48` perform the following sequence of opperations: `jmp -1; inc eax; dec eax;` effectively doing nothing. However, linear dissassemblers will incorrectly see the second command as `eax dec;` and not be able to progress.</p>|
|8. *The defender may be running your malware inside a standard sandbox for quick dynamic analysis.*|<p>1. My first approach to bypassing standard sandbox analysis is simply to immediately sleep for 10 minutes on execution, this is because some sandboxes only anaylse for a few minutes!</p><p>2. My second anti-sandbox technique was to check whether the number of running processes is less than 15. This is because most sandboxes are lightweight for quick and effecicient analysis, as such they often run with minimal processes!</p>|
|9. *They may also run your malware executable in a debugger like OllyDbg or x64dbg for deep dynamic analysis. They may try to set breakpoints, trace execution, or step through code.*|<p>1. The first anti-debugger technique I utilised was a time-based check each time a command is executed on the client side. The `processCommands` method in the `commands.c` file sequentially executes each command recieved from the C2 server by calling the `executeCommand` method, a likely target for an analyst to debug. As such, I compute the time it takes to execute the command, if it is greater than 2.5 seconds then a breakpoint has likely been set and the process immediately terminates.</p><p>2. My second anti-debugger technique is to simply envoke the Windows API function `IsDebuggerPresent`, if it returns true then terminate immediately!</p><p>3. The final anti-debugging technique I employed was to utilise `SetLastError`, `OutputDebugString`, and `GetLastError`. If the set error value changes then we likely know that a debugger is present.</p><p>I also employed process enumeration to check for running processes with names such as "OLLYDBG" or "Dbg" (for WinDbg), however, I will credit process enumeration in the next defense.|
|10. *The defender may be analysing your malware for deep analysis inside a virtual machine, e.g. using VirtualBox.*|<p>1. Virtual Machine's (VM) create registry keys to store configurations, settings, and facilitate VM to host exchanges. However, these keys also allow malware to determine if its in a vitual environment, as such, my first anti-malware technique simply checks for the existence of a range of known VMware and VirtualBox (VBox) registry keys using `RegOpenKeyExA`, if one is found then the process immediately terminates.</p><p>2. My second anti-VM technique is to enumerate all running processes and check whether their name matches known processes associated with the VM providers VMware and VBox. For example, "vmtoolsd" (VMware) and "VBoxService" (VBox) are two such background processes that if detected caused the malware to instantly terminate.</p><p>3. My last anti-VM technique inspects the first six characters of the client machine's MAC address for known VM provider MAC ranges. For example, VBox version 5.2 and later utilises the prefix "08:00:27" and many VMware machines MACs start with "00:50:56". As such, if the clients MAC matches that of a known VM provider the malware immediately exits.</p>|
|11. *The malware analyst will eventually find the hard-coded key and will be able to decipher the communications of malware with the C2.*|1. I bypassed this defence by generating a random single-byte encoding key for each new client on the server-side, instead of hard-coding the key in both the client and C2. When a client registers with the C2 it responds with the random byte, ensuring that if the encoding key is discovered on one infected machine it cannot be used to decipher communication of other infected machines!|
|12. *The malware analyst will spoof the C&C server itself to send the shutdown command to all hosts on the network to try and deactivate the malware ("kill-switch").*|1. This defense is bypassed as all commands sent to the malware are encoded using the previously mentioned random encoding key. As such, the spoofed C2 server might try and send the command `shd <user_id>` to every client that attempts to poll commands. However, unless the spoofed C2 knows the correct encoding key for each client, then when the command is recieved and decoded by the malware it will not be recognised as a valid command. As such, the spoofed C2 would need to correctly encode each of the shutdown messags for every infected client in order successfully shut down each one!|
|13. *The defender may look for suspicious processes or unusual binaries on disk. They may trust processes signed by Microsoft or running from `C:\Windows\System32`*.|1. My malware bypasses this defense by creating and launching a copy of itself in the `System32` directory when it is first launched. When the privileged version is launched, it recieves `-007` and its current path as command line arguments, indicating that it is being run from `System32` and that it should delete the old malware!|

### Dependencies and Assumptions
The only dependecy for my malware is that when it is first executed it must be done so with administrator privileges.